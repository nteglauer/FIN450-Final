---
title: "FIN450 Final Assignment"
output: html_document
date: "2023-11-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries}
library(tidyverse)
library(RSelenium)
library(netstat)
library(jsonlite)
library(robotstxt)
library(rvest)
library(openxlsx)
library(kableExtra)
library(broom)
library(plotly)
library(rstanarm)
library(parsnip)
library(tidymodels)
library(rsample)
library(recipes)
library(yardstick)

```

```{r remDr Start, eval=FALSE, include=FALSE}
# Start the server
rs_driver_object <- rsDriver(browser = "firefox",
                             chromever = NULL,
                             verbose = FALSE
                             )

# Create a Client object
remDr <- rs_driver_object$client
```

```{r scraping new release, eval=FALSE, include=FALSE}
library(rvest)
library(stringr)
library(dplyr)
library(tidyr)

# Replace 'your_url_here' with the actual URL of the webpage
url <- "https://www.imdb.com/calendar/?ref_=rlm&region=US&type=MOVIE"

# Read the HTML content of the webpage
webpage <- read_html(url)

# Use the identified CSS selector for the movie elements
movie_elements <- html_nodes(webpage, '.ipc-metadata-list-summary-item')

# Initialize an empty list to store data for each movie
movies_data <- list()

# Loop through each movie element
for (i in seq_along(movie_elements)) {
  # Extract title
  title <- html_text(html_node(movie_elements[[i]], '.ipc-metadata-list-summary-item__t'))

  # Extract year (assuming it's within the title link)
  year <- gsub("[^0-9]", "", str_match(title, "\\((\\d{4})\\)")[, 2])

  # Extract genres
  genres <- html_text(html_nodes(movie_elements[[i]], '.ipc-inline-list--show-dividers.ipc-metadata-list-summary-item__tl .ipc-inline-list__item'))

  # Extract stars
  stars <- html_text(html_nodes(movie_elements[[i]], '.ipc-inline-list--show-dividers.ipc-metadata-list-summary-item__stl .ipc-inline-list__item'))

  # Store the data for the current movie in a list
  movie_data <- list(title = title, year = year, genres = paste(genres, collapse = ", "), stars = paste(stars, collapse = ", "))

  # Append the list to the movies_data list
  movies_data <- append(movies_data, list(movie_data))
}

# Convert the list of lists into a data frame
new_movies_df <- bind_rows(movies_data)

# Print the resulting data frame
print(new_movies_df)

```

```{r Revenue For the top movies_per_page movies of each year from 2024 - num_pages, eval=FALSE, include=FALSE}

#Scrapes the revenue of each movie flipping through each year.
scrape_revenue_data <- function(num_pages) {
  all_data <- list()  # Initialize an empty list to store the collected data

  for (page in 1:(num_pages)) {
    # Click the year drop down
    drop_down <- remDr$findElement(using = 'css selector', '.mojo-refinement')$clickElement()
    remDr$findElement(using = 'css selector',  paste0('li.a-dropdown-item:nth-child(', page, ')'))$clickElement()
    
    # Pause
    Sys.sleep(1)
    
    # Read the HTML of the current page
    url <- as.character(remDr$getCurrentUrl())
    webpage <- read_html(url)
    
    # Extract the table data 
    table_data <- webpage %>% 
      html_nodes("#table table") %>% 
      html_table(fill = TRUE)
    
    # Add the "Year" column
    table_data <- lapply(table_data, function(df) { df$Year <- 2024 - page; return(df) })
    
    # Add the data to the overall list
    all_data <- c(all_data, list(table_data))
  }
  
  return(all_data)
}

```

```{r Extract Movie Specific Data, eval=FALSE, include=FALSE}

#Scrapes the Movie specific data, returns a wide df of the movie's data
extract_movie_data <- function(webpage, title) {
  # Target the specific div that contains the table rows
  table_nodes <- webpage %>% 
    html_nodes(".mojo-summary-values .a-section.a-spacing-none")
  
  # Initialize empty lists to store headers and values
  headers <- c()
  values <- c()
  
  # Iterate through each table row
  for (node in table_nodes) {
    # Extract the header
    header <- node %>% html_node("span:nth-child(1)") %>% html_text()
    
    # Extract the value
    value_node <- node %>% html_node("span:nth-child(2)")
    value <- value_node %>% html_text(trim = TRUE)
    
    # Append the header and value to the lists
    headers <- c(headers, header)
    values <- c(values, value)
  }
  
  # Combine headers and values into a data frame
  table_data <- data.frame(Header = headers, Value = values)
  table_data$Title <- title
  movie_wide <- table_data %>% 
    tidyr::pivot_wider(names_from = Header, values_from = Value)
  
  # Collect crew table
  crew_table <- webpage %>% 
    html_nodes("#principalCrew") %>% 
    html_table(fill = TRUE)
 
  if (length(crew_table) == 0) {
    crew_df <- data.frame(Crew = character(), stringsAsFactors = FALSE)
  } else {
    # If crew_table is not empty, proceed with data processing
    crew_df <- crew_table[[1]] %>% 
    group_by(Role) %>% 
    summarize(NameCombined = paste(Filmmakers, collapse = ", ")) %>% 
    ungroup() %>% 
    pivot_wider(names_from = Role, 
                values_from = NameCombined)
  }
  
  # Collect Cast table
  cast_table <- webpage %>% 
    html_nodes("#principalCast") %>% 
    html_table(fill = TRUE)

  # Check if cast_table is not empty before proceeding
  if (length(cast_table) == 0) {
    cast_df <- data.frame(Cast = character(), stringsAsFactors = FALSE)
  } else {
    # If cast_table is not empty, proceed with data processing
    cast_df <- cast_table[[1]] %>% 
      as.data.frame() %>% 
      mutate(Cast = paste(Cast, collapse = ", ")) %>% 
      pull(Cast) %>% 
      unname() %>% 
      tibble(Cast = .) %>% 
      dplyr::distinct(Cast)
  }
  
  # Check if table exists and binds existing ones
  if (!is.null(cast_df) && nrow(cast_df) > 0) {
    df_wide <- cbind(movie_wide, cast_df, crew_df)
  } else {
    df_wide <- cbind(movie_wide, crew_df)
  }

  
  return(df_wide)
}

```

```{r Flip through Movies within each Year and Aggregate, eval=FALSE, include=FALSE}

# Flips through each Movie within each Year and aggregates the specific year's movie data
scrape_movie_data <- function(movie_titles) {
  movie_df <- tibble()
  for (title in movie_titles) {
    # Find and click the link for the current movie title
    address <- as.character(remDr$getCurrentUrl())
    movie_link <- remDr$findElement(using = 'link text', title)$clickElement()
    
    
    print(title)
    remDr$findElement(using = 'link text', 'Title Summary')$clickElement()
    remDr$findElement(using = 'link text', 'Cast and Crew')$clickElement()
    
    url <- as.character(remDr$getCurrentUrl())
    webpage <- read_html(url)
    movie_data <- extract_movie_data(webpage, title)
    
    # Append the movie_data to the global movie_df
    movie_df <- bind_rows(movie_df, movie_data)
    
    remDr$navigate(address)
    
    # Pause
    Sys.sleep(1)
  }
  return(movie_df)
}

```

```{r Flip through Each year and Aggregate each year's movie data, eval=FALSE, include=FALSE}

#Flips through each year and aggregates all year's data
scrape_and_aggregate_data <- function(num_pages, movies_per_page, movie_titles) {
  # Initialize an empty data frame to store aggregated movie data
  final_df <- tibble()
  
  for (page in 1:num_pages) {
    # Calculate the start and end indices for the current page
    start_index <- (page - 1) * movies_per_page + 1
    end_index <- page * movies_per_page
    
    # Extract movie titles for the current page
    current_page_titles <- movie_titles[start_index:end_index]
    
    # Scrape movie specific data
    movie_df <- scrape_movie_data(current_page_titles)
    final_df <- bind_rows(final_df, movie_df)
    
    # Click the year drop down
    drop_down <- remDr$findElement(using = 'css selector', '.mojo-refinement')$clickElement()
    remDr$findElement(using = 'css selector', paste0('li.a-dropdown-item:nth-child(', page + 1, ')'))$clickElement()
    
    # Pause
    Sys.sleep(1)
  }
  
  return(final_df)
}
```

```{r MAIN, eval=FALSE, include=FALSE}
website <- 'https://www.boxofficemojo.com/'
remDr$open()
remDr$navigate(website)
alltime <- remDr$findElement(using = 'link text', 'Worldwide')$clickElement()

#RUN EVERYTHING UNDER HERE TO TEST 

#CHANGE AS NEEDED
num_pages <- 25 
movies_per_page <- 75

# Collect Revenue data
result_data <- scrape_revenue_data(num_pages)
rev_df <- bind_rows(result_data)
# Fix title for movies with (Re-release) to align with website html identifier
rev_df$`Release Group` <- gsub("\\s{2,}(Re-release)", " \\1", rev_df$`Release Group`)
rev_df <- rev_df %>% 
  dplyr::filter(Rank <= movies_per_page)

rev_df

movie_titles <- rev_df$`Release Group`

# Return to first page
drop_down <- remDr$findElement(using = 'css selector', '.mojo-refinement')$clickElement()
remDr$findElement(using = 'css selector',  paste0('li.a-dropdown-item:nth-child(1)'))$clickElement()


movie_df <- scrape_and_aggregate_data(num_pages, movies_per_page, movie_titles)

# Aggregate movie_df and rev_df 
combined_df <- cbind(rev_df, movie_df)

combined_df

# Change File Location to save data
write.xlsx(combined_df, 'C:/Users/jamie/OneDrive/School/FALL 2023/FIN 450/Final/FIN450-Final/scraped_data.xlsx', rowNames = FALSE)
```

```{r Data Wrangling and Parsing, include=FALSE}

library(lubridate)
library(readxl)
library(dplyr)
library(tidyr)
url <- "https://raw.githubusercontent.com/nteglauer/FIN450-Final/master/combined_df.xlsx"
download.file(url, destfile = "combined_df.xlsx", mode = "wb")
combined_all <- read_excel("combined_df.xlsx")



temp <- combined_all %>% 
  dplyr::select(-Title)

df <- temp[, -15] %>% 
  dplyr::rename(Title = `Release Group`,
                `% Domestic` = `%...5`,
                `% Foreign` = `%...7`,
                Distributor = `Domestic Distributor`) %>% 
  dplyr::mutate(Distributor = sub("See full company information$", "", Distributor),
                Worldwide = parse_number(gsub("[$,]", "", Worldwide)),
                Domestic = parse_number(gsub("[$,]", "", Domestic)),
                Foreign = parse_number(gsub("[$,]", "", Foreign)),
                `Domestic Opening` = parse_number(gsub("[$,]", "", `Domestic Opening`)),
                Budget = parse_number(gsub("[$,]", "", Budget)),
                `% Domestic` = as.numeric(parse_number(`% Domestic`)) / 100,
                `% Foreign` = as.numeric(parse_number(`% Foreign`)) / 100,
                `Earliest Release Date` = mdy(str_extract(`Earliest Release Date`, "[A-Za-z]+ [0-9]+, [0-9]+")),
                Star = str_split(Cast, ", ") %>% map_chr(1),
                Hours = as.numeric(str_extract(`Running Time`, "\\d+(?= hr)")),
                Minutes = as.numeric(str_extract(`Running Time`, "\\d+(?= min)")),
                Hours = ifelse(is.na(Hours), 0, Hours),
                Minutes = ifelse(is.na(Minutes), 0, Minutes),
                `Run Time (Mins)` = Hours * 60 + Minutes,
                Genres = strsplit(Genres, "\r\n[[:space:]]*\\r\\n"),
                Genres = sapply(Genres, function(x) paste(trimws(x), collapse = ", "))) %>%
                dplyr::select(-c(`Running Time`, Hours, Minutes)) %>% 
  
  dplyr::filter(!grepl("Re-release", Title, ignore.case = TRUE))

df <- df %>%
  dplyr::mutate("Release Month" = month(`Earliest Release Date`, label = TRUE)) %>%
  dplyr::mutate(`Release Month` = as.character(`Release Month`)) %>%
  mutate(`First Genre` = sapply(strsplit(Genres, ", "), `[`, 1)) %>%
  mutate(count_genres = str_count(Genres, ", ") + 1)
df


```

```{r import economic data}

library(tidyr)
library(tidyquant)
library(dplyr)

# Set get ="economic.data" in tq_get()
import_economic_data <- tidyquant::tq_get(c("DPCCRV1Q225SBEA", "UNRATE", "DGS10"),
                                         get  = "economic.data",
                                         from = "1999-01-01",
                                         to   = Sys.Date()) %>% 
  dplyr::mutate(symbol = dplyr::case_when(symbol == "DPCCRV1Q225SBEA" ~ "Consumer Spending % (USA)",
                                          symbol == "UNRATE" ~ "Unemployment Rate % (USA)",
                                          symbol == "DGS10" ~ "U.S Treasury Yield "))

economic_data <- import_economic_data %>%
  tidyr::pivot_wider(names_from = symbol, values_from = price) %>%
  tidyr::complete(date = seq.Date(from = min(date), to = max(date), by = "1 month")) %>%
  dplyr::arrange(date)  %>%
  dplyr::select(date, `Consumer Spending % (USA)`) %>%
  tidyr::drop_na()

economic_data # df that includes Consumer Spending, Unemployment Rate, and Fed Funds Rate in the United States with aligned dates


theatre_stocks <- tidyquant::tq_get(
  c("IMAX", "CGX", "SPY"),
  get  = "stock.prices",
) %>%
  dplyr::transmute(date, series = symbol, value = adjusted) %>%
  dplyr::group_by(series) %>%
  dplyr::mutate(
    ret = log(value / dplyr::lag(value))
  ) %>%
  dplyr::select(-value) %>%
  tidyr::pivot_wider(names_from = series, values_from = ret) %>%
  tidyr::drop_na()


theatre_stocks #includes returns daily for IMAX and Cineplex stocks


```

REPORT LAYOUT:
- Introduction
- General Analysis and insights (try to find unique insights)
- Analysis of factors affecting revenue 
- ML and prediction of select movies

# **Executive Summary**
1. 
2.
3.
4.

## **Project Framework: Definition and Methodology**
In this report, we will explore the various factors that impact and influence the monetary success of a movie at the box office. Our investigation extends beyond mere fiscal considerations, encompassing a nuanced examination of critical determinants such as the expertise of the cast and crew. By scrutinizing these diverse components, the report aims to provide a comprehensive understanding of the factors that defines a movie's monetary success at the box office.

The data was obtained through the use of our own web scraping algorithm and covers the top 75 grossing movies over the past 25 years.
 
 
## **Temporal Analysis**
The average revenue earned over time shows a very clear increasing trend. An important observation to note is the rate at which Foreign revenue grows in relation to Domestic revenue. The growth in worldwide revenue can be attributed to the rapid growth in average foreign revenue.

```{r Movie Revenue Trends over Time, echo=FALSE, warning=FALSE}

revenue <- df %>% 
  dplyr::select(Title, Worldwide, Domestic, Foreign,`Domestic Opening`, `Earliest Release Date`, Year) %>% 
  dplyr::filter(`Earliest Release Date` >= "1999-01-01") %>% 
  stats::na.omit() %>% 
  dplyr::group_by(Year) %>% 
  dplyr::summarise(Avg_Worldwide = mean(Worldwide),
                   Avg_Domestic = mean(Domestic),
                   Avg_Foreign = mean(Foreign))

revenue_plot <- revenue %>% 
  ggplot(aes(x = Year)) +
  geom_line(aes(y = Avg_Worldwide, color = "Avg Worldwide"), size = 1) +
  geom_line(aes(y = Avg_Domestic, color = "Avg Domestic"), size = 1) +
  geom_line(aes(y = Avg_Foreign, color = "Avg Foreign"), size = 1) +
  labs(title = "Avg Revenue Over Time",
       x = "Release Date",
       y = "Revenue (in millions)",
       color = "Revenue Type") +
  theme_minimal()
  
revenue_plot

```

```{r Release Month Analysis}

release_month <- df %>% 
  dplyr::select(Title, Worldwide, `Earliest Release Date`) %>% 
  dplyr::mutate(Month = month(`Earliest Release Date`, label = TRUE))

release_month_plot <- release_month %>% 
  dplyr::group_by(Month) %>% 
  dplyr::summarise(AvgRevenue = mean(Worldwide)) %>% 
  ggplot(aes(x = Month, y = AvgRevenue, fill = Month)) +
    geom_bar(stat = "identity") +
    labs(title = "Average Revenue by Release Month", x = "Release Month", y = "Average Revenue") +
  theme(legend.position = "none")

release_month_plot

# Anova Analysis shows low P value: there are significant differences in the average revenue across different months of movie releases. 
release_month_anova <- aov(Worldwide ~ Month, data = release_month)
anova_table <- kable(tidy(release_month_anova)) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
anova_table
```

```{r Genre Analysis}

genre <- df %>% 
  dplyr::select(Title, Worldwide, Genres) %>% 
  tidyr::separate_rows(Genres, sep = ", ")

genre_plot <- genre %>% 
  ggplot(aes(x = Genres, y = Worldwide, fill = Genres)) +
  geom_boxplot() +
  coord_flip() +  # To make the plot horizontal for better readability
  labs(title = "Distribution of Revenue Across Genres",
       x = "Genres",
       y = "Revenue") +
  theme(legend.position = "none")
  
genre_plot

# Used Median b/c of presence of outliers
genre_summary <- genre %>%
  group_by(Genres) %>%
  summarise(Median_Revenue = median(Worldwide, na.rm = TRUE)) %>%
  arrange(desc(Median_Revenue)) %>% 
  head(10) %>% 
  kbl(caption = "Top 10 Genres by Revenue",
      col.names = c("Genre", "Median Revenue")) %>% 
  kable_classic(full_width = F, html_font = "Times New Roman")


genre_summary

genre_distribution <- genre %>% 
  dplyr::group_by(Genres) %>% 
  dplyr::summarise(Movie_Count = n()) %>% 
  arrange(desc(Movie_Count)) %>% 
  ggplot(aes(x = Genres, y = Movie_Count, fill = Genres)) +
  geom_bar(stat = "identity") +
  labs(title = "Distribution of Movies Across Different Genres",
         x = "Genres",
         y = "Movie Count") +
  coord_flip() +
  theme(legend.position = "none")

genre_distribution

genres_per_movie <- df %>% 
  dplyr::select(Title, Worldwide, Genres) %>% 
  dplyr::mutate(Genre_Count = str_count(Genres, ",") + 1) %>% 
  dplyr::group_by(Genre_Count) %>% 
  dplyr::summarise(Median_rev = median(Worldwide),
                   Movie_Count = n()) %>% 
  ggplot(aes(x = factor(Genre_Count), y = Median_rev, fill = factor(Genre_Count))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Movie_Count), vjust = -0.5) +  # Display movie count on top of bars
  labs(title = "Median Revenue by Number of Genres and Number of Movies",
       x = "Number of Genres",
       y = "Median Revenue") +
  theme_minimal() +
  theme(legend.position = "none")

genres_per_movie
```

```{r Cast Analysis}
cast <- df %>% 
  dplyr::select(Title, Worldwide, Cast) %>% 
  tidyr::separate_rows(Cast, sep = ", ") %>% 
  dplyr::group_by(Cast) %>% 
  dplyr::summarise(AvgRev = mean(Worldwide),
                   Count = n()) %>% 
  dplyr::mutate(Movies_Acted = case_when(
    Count >= 5 & Count <= 10 ~ '5-10',
    Count > 10 & Count <= 15 ~ '10-15',
    Count > 15 & Count <= 20 ~ '15-20',
    Count > 20 ~ '20+',
    TRUE ~ 'Less than 5'
  )) %>% 
  dplyr::group_by(Movies_Acted) %>% 
  dplyr::summarise(AvgRev = mean(AvgRev),
                   Count = n()) %>% 
  dplyr::arrange(desc(AvgRev))
cast
# Changing preference for newer faces or different types of story telling. Still like regulars 
range_order <- c("Less than 5", "5-10", "10-15", "15-20", "20+")
cast$Movies_Acted <- factor(cast$Movies_Acted, levels = range_order)
ggplot(cast, aes(x = Movies_Acted, y = AvgRev, fill = factor(Count))) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  scale_fill_viridis_d() +
  labs(title = "Average Revenue by Number of Movies Acted",
       x = "Movies_Acted",
       y = "Average Revenue",
       fill = "Count") +
  theme_minimal()
star <- df %>% 
  dplyr::select(Worldwide, Star) %>% 
  dplyr::group_by(Star) %>% 
  dplyr::summarise(AvgRev = mean(Worldwide),
                   Count = n()) %>% 
  dplyr::filter(Count >= 5) %>% 
  dplyr::arrange(desc(AvgRev))
star
star_plot <- star %>%  
  ggplot(aes(x = Count, y = AvgRev, size = Count, color = Count,
             text = paste("Star:", Star, "<br>Number of Movies:", Count, "<br>Average Revenue:", scales::dollar(AvgRev)))) +
  geom_point() +
  labs(title = "Movie Stars and Avg Revenue",
       x = "Number of Movies",
       y = "Average Revenue",
       size = "Number of Movies")
plotly::ggplotly(star_plot, tooltip = "text")
```

MACHINE LEARNING

```{r regression tree analysis}

library(dplyr)
library(parsnip)
library(ggplot2)
# Split data
set.seed(123)  # Set a seed for reproducibility
#df_shuffled <- df[sample(nrow(df)), ] # Shuffle data to elimate some bias hopefully/
df_split <- df %>% rsample::initial_split(prop = 0.80)
df_train <- rsample::training(df_split)
df_test  <- rsample::testing(df_split)

# Worldwide as dependent variable
recipe_pipeline <- recipes::recipe(Worldwide ~ Budget + Distributor + `Release Month` + MPAA + `Run Time (Mins)` + `First Genre`+`count_genres`, data = df_train) %>%
  # step_rm(date) %>%
  recipes::prep()

train_baked <- recipes::bake(recipe_pipeline, df_train)

recipe_pipeline <- recipes::recipe(Worldwide ~ Budget + Distributor + `Release Month` + MPAA + `Run Time (Mins)` + `First Genre`+`count_genres`, data = df_test) %>%
  # step_rm(date) %>%
  recipes::prep()

test_baked <- recipes::bake(recipe_pipeline, df_test)  # Corrected to use test_baked


common_levels_distributor <- intersect(levels(train_baked$Distributor), levels(test_baked$Distributor))
train_baked$Distributor <- factor(train_baked$Distributor, levels = common_levels_distributor)
test_baked$Distributor <- factor(test_baked$Distributor, levels = common_levels_distributor)



# Modeling
model <- parsnip::decision_tree(mode = "regression") %>%
  parsnip::set_engine("rpart") %>%
  parsnip::fit(Worldwide ~ Budget + Distributor + `Release Month` + MPAA + `Run Time (Mins)` + `First Genre`+`count_genres`, data = train_baked)
model

test_predictions <- predict(model, new_data = test_baked)
test_predictions


# Plot tree
library(rpart.plot)
rpart.plot(
  model$fit,
  roundint = F,
  cex = 1,
  fallen.leaves = F,
  extra = "auto",
  main = "Regression Tree"
)

# Results
res <- model %>% predict(new_data = test_baked) %>%
  bind_cols(test_baked %>% dplyr::select(Worldwide))
res %>% yardstick::metrics(truth = Worldwide, estimate = .pred)

res %>% ggplot(aes(x = .pred, y = Worldwide)) + geom_point() +
  labs(title = "Prediction vs Actual",
       subtitle = "Decision Tree - Regression")

# Assuming 'model' is your decision tree model and 'df_test' is your testing data
library(parsnip)
library(yardstick)
library(vip)

# Assess variable importance
importance <- model %>% vip()

# Assess variable relationships
plot(importance)


```

```{r}

# Example: Create a data frame for prediction
unreleased_movie_data <- data.frame(
  Budget = 90000000,  # Replace with the actual budget value
  Distributor = "Lions Gate Studios",  # Replace with the actual distributor value
  `Release Month` = "Jan",  # Replace with the actual release month value
  MPAA = "PG",  # Replace with the actual MPAA rating value
  `Run Time (Mins)` = 1,
  `First Genre` = "Comedy",
  `count_genres` =0# Replace with the actual run time value
)

library(dplyr)

# Example: Rename columns in the tibble
unreleased_movie_data <- unreleased_movie_data %>%
  dplyr::rename(
    Budget = Budget,
    Distributor = Distributor,
    `Release Month` = `Release.Month`,
    MPAA = MPAA,
    `Run Time (Mins)` = `Run.Time..Mins.`,
    `First Genre` = `First.Genre`
  )


unreleased_movie_data

unreleased_movie_baked <- recipes::bake(recipe_pipeline, unreleased_movie_data)
prediction <- predict(model, unreleased_movie_baked)

print(prediction)


```

```{r}
# Sampling
df_split2 <- df %>% rsample::initial_time_split(prop = 0.80)
df_train2 <- rsample::training(df_split2)
df_test2 <- rsample::testing(df_split2)

# Training Data
recipe_pipeline2 <- recipes::recipe(Worldwide ~ Budget + 
                                      Distributor + 
                                      `Earliest Release Date` + 
                                      MPAA + 
                                      `Run Time (Mins)` + 
                                      Star, 
                                    data = df_train2) %>%
  recipes::step_mutate(Budget_Category = cut(Budget, 
                                     breaks = c(-Inf, 75000000, 150000000, Inf), 
                                     labels = c("Small", "Medium", "Large"))) %>% 
  step_mutate(Release_Month = month(`Earliest Release Date`, label = TRUE)) %>%
  step_mutate(Run_Time_Category = ifelse(`Run Time (Mins)` < 120, "Regular", "Long")) %>%
  step_rm(`Run Time (Mins)`, `Earliest Release Date`, Budget) %>% 
  recipes::prep()

train_baked2 <- recipes::bake(recipe_pipeline2, df_train2)

#Testing Data
recipe_pipeline2 <- recipes::recipe(Worldwide ~ Budget + 
                                      Distributor + 
                                      `Earliest Release Date` + 
                                      MPAA + 
                                      `Run Time (Mins)` +
                                      Star, 
                                    data = df_test2) %>%
  recipes::step_mutate(Budget_Category = cut(Budget, 
                                     breaks = c(-Inf, 75000000, 150000000, Inf), 
                                     labels = c("Small", "Medium", "Large"))) %>% 
  step_mutate(Release_Month = month(`Earliest Release Date`, label = TRUE)) %>%
  step_mutate(Run_Time_Category = ifelse(`Run Time (Mins)` < 120, "Regular", "Long")) %>%
  step_rm(`Run Time (Mins)`, `Earliest Release Date`, Budget) %>% 
  recipes::prep()

test_baked2 <- recipes::bake(recipe_pipeline2, df_test2)

common_levels_distributor2 <- intersect(levels(train_baked2$Distributor), levels(test_baked2$Distributor))
train_baked2$Distributor <- factor(train_baked2$Distributor, levels = common_levels_distributor2)
test_baked2$Distributor <- factor(test_baked2$Distributor, levels = common_levels_distributor2)

common_levels_star <- intersect(levels(train_baked2$Star), levels(test_baked2$Star))

# Update levels in both training and testing data
train_baked2$Star <- factor(train_baked2$Star, levels = common_levels_star)
test_baked2$Star <- factor(test_baked2$Star, levels = common_levels_star)

# MODEL
lm_fit <- parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine("lm") %>%
  parsnip::fit(Worldwide ~ ., data = train_baked2)

# Make predictions on the test data
lm_predictions <- predict(lm_fit, new_data = test_baked2) %>%
  bind_cols(truth = df_test2$Worldwide)

# Calculate performance metrics
lm_metrics <- lm_predictions %>%
  metrics(truth = truth, estimate = .pred)

# Extract specific metrics
mae <- lm_metrics$mae
rmse <- sqrt(lm_metrics$mse)
rsq <- lm_metrics$r.squared

# Create a table
metrics_table <- tibble::tibble(
  Model = "Linear Regression",
  MAE = mae,
  RMSE = rmse,
  R_squared = rsq
)

# Print the table
print(metrics_table)

test <- df %>% 
  dplyr::group_by(Distributor) %>% 
  dplyr::summarise(count = n()) %>% 
  dplyr::arrange(desc(count))
test

```

