---
title: "FIN450 Final Assignment"
output: html_document
date: "2023-11-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(RSelenium)
library(netstat)
library(jsonlite)
library(robotstxt)
library(rvest)
library(openxlsx)
library(kableExtra)
library(broom)
library(plotly)
library(rstanarm)
library(parsnip)
library(tidymodels)
library(rsample)
library(recipes)
library(yardstick)
library(arrow)
library(feasts)
library(patchwork)
library(corrplot)

```

```{r remDr Start, eval=FALSE, include=FALSE}
# Start the server
rs_driver_object <- rsDriver(browser = "firefox",
                             chromever = NULL,
                             verbose = FALSE
                             )

# Create a Client object
remDr <- rs_driver_object$client
```

```{r scraping new release, eval=FALSE, include=FALSE}
library(rvest)
library(stringr)
library(dplyr)
library(tidyr)

# Replace 'your_url_here' with the actual URL of the webpage
url <- "https://www.imdb.com/calendar/?ref_=rlm&region=US&type=MOVIE"

# Read the HTML content of the webpage
webpage <- read_html(url)

# Use the identified CSS selector for the movie elements
movie_elements <- html_nodes(webpage, '.ipc-metadata-list-summary-item')

# Initialize an empty list to store data for each movie
movies_data <- list()

# Loop through each movie element
for (i in seq_along(movie_elements)) {
  # Extract title
  title <- html_text(html_node(movie_elements[[i]], '.ipc-metadata-list-summary-item__t'))

  # Extract year (assuming it's within the title link)
  year <- gsub("[^0-9]", "", str_match(title, "\\((\\d{4})\\)")[, 2])

  # Extract genres
  genres <- html_text(html_nodes(movie_elements[[i]], '.ipc-inline-list--show-dividers.ipc-metadata-list-summary-item__tl .ipc-inline-list__item'))

  # Extract stars
  stars <- html_text(html_nodes(movie_elements[[i]], '.ipc-inline-list--show-dividers.ipc-metadata-list-summary-item__stl .ipc-inline-list__item'))

  # Store the data for the current movie in a list
  movie_data <- list(title = title, year = year, genres = paste(genres, collapse = ", "), stars = paste(stars, collapse = ", "))

  # Append the list to the movies_data list
  movies_data <- append(movies_data, list(movie_data))
}

# Convert the list of lists into a data frame
new_movies_df <- bind_rows(movies_data)

# Print the resulting data frame
print(new_movies_df)

```

```{r Revenue For the top movies_per_page movies of each year from 2024 - num_pages, eval=FALSE, include=FALSE}

#Scrapes the revenue of each movie flipping through each year.
scrape_revenue_data <- function(num_pages) {
  all_data <- list()  # Initialize an empty list to store the collected data

  for (page in 1:(num_pages)) {
    # Click the year drop down
    drop_down <- remDr$findElement(using = 'css selector', '.mojo-refinement')$clickElement()
    remDr$findElement(using = 'css selector',  paste0('li.a-dropdown-item:nth-child(', page, ')'))$clickElement()
    
    # Pause
    Sys.sleep(1)
    
    # Read the HTML of the current page
    url <- as.character(remDr$getCurrentUrl())
    webpage <- read_html(url)
    
    # Extract the table data 
    table_data <- webpage %>% 
      html_nodes("#table table") %>% 
      html_table(fill = TRUE)
    
    # Add the "Year" column
    table_data <- lapply(table_data, function(df) { df$Year <- 2024 - page; return(df) })
    
    # Add the data to the overall list
    all_data <- c(all_data, list(table_data))
  }
  
  return(all_data)
}

```

```{r Extract Movie Specific Data, eval=FALSE, include=FALSE}

#Scrapes the Movie specific data, returns a wide df of the movie's data
extract_movie_data <- function(webpage, title) {
  # Target the specific div that contains the table rows
  table_nodes <- webpage %>% 
    html_nodes(".mojo-summary-values .a-section.a-spacing-none")
  
  # Initialize empty lists to store headers and values
  headers <- c()
  values <- c()
  
  # Iterate through each table row
  for (node in table_nodes) {
    # Extract the header
    header <- node %>% html_node("span:nth-child(1)") %>% html_text()
    
    # Extract the value
    value_node <- node %>% html_node("span:nth-child(2)")
    value <- value_node %>% html_text(trim = TRUE)
    
    # Append the header and value to the lists
    headers <- c(headers, header)
    values <- c(values, value)
  }
  
  # Combine headers and values into a data frame
  table_data <- data.frame(Header = headers, Value = values)
  table_data$Title <- title
  movie_wide <- table_data %>% 
    tidyr::pivot_wider(names_from = Header, values_from = Value)
  
  # Collect crew table
  crew_table <- webpage %>% 
    html_nodes("#principalCrew") %>% 
    html_table(fill = TRUE)
 
  if (length(crew_table) == 0) {
    crew_df <- data.frame(Crew = character(), stringsAsFactors = FALSE)
  } else {
    # If crew_table is not empty, proceed with data processing
    crew_df <- crew_table[[1]] %>% 
    group_by(Role) %>% 
    summarize(NameCombined = paste(Filmmakers, collapse = ", ")) %>% 
    ungroup() %>% 
    pivot_wider(names_from = Role, 
                values_from = NameCombined)
  }
  
  # Collect Cast table
  cast_table <- webpage %>% 
    html_nodes("#principalCast") %>% 
    html_table(fill = TRUE)

  # Check if cast_table is not empty before proceeding
  if (length(cast_table) == 0) {
    cast_df <- data.frame(Cast = character(), stringsAsFactors = FALSE)
  } else {
    # If cast_table is not empty, proceed with data processing
    cast_df <- cast_table[[1]] %>% 
      as.data.frame() %>% 
      mutate(Cast = paste(Cast, collapse = ", ")) %>% 
      pull(Cast) %>% 
      unname() %>% 
      tibble(Cast = .) %>% 
      dplyr::distinct(Cast)
  }
  
  # Check if table exists and binds existing ones
  if (!is.null(cast_df) && nrow(cast_df) > 0) {
    df_wide <- cbind(movie_wide, cast_df, crew_df)
  } else {
    df_wide <- cbind(movie_wide, crew_df)
  }

  
  return(df_wide)
}

```

```{r Flip through Movies within each Year and Aggregate, eval=FALSE, include=FALSE}

# Flips through each Movie within each Year and aggregates the specific year's movie data
scrape_movie_data <- function(movie_titles) {
  movie_df <- tibble()
  for (title in movie_titles) {
    # Find and click the link for the current movie title
    address <- as.character(remDr$getCurrentUrl())
    movie_link <- remDr$findElement(using = 'link text', title)$clickElement()
    
    
    print(title)
    remDr$findElement(using = 'link text', 'Title Summary')$clickElement()
    remDr$findElement(using = 'link text', 'Cast and Crew')$clickElement()
    
    url <- as.character(remDr$getCurrentUrl())
    webpage <- read_html(url)
    movie_data <- extract_movie_data(webpage, title)
    
    # Append the movie_data to the global movie_df
    movie_df <- bind_rows(movie_df, movie_data)
    
    remDr$navigate(address)
    
    # Pause
    Sys.sleep(1)
  }
  return(movie_df)
}

```

```{r "Flip through Each year and Aggregate each year's movie data", eval=FALSE, include=FALSE}

#Flips through each year and aggregates all year's data
scrape_and_aggregate_data <- function(num_pages, movies_per_page, movie_titles) {
  # Initialize an empty data frame to store aggregated movie data
  final_df <- tibble()
  
  for (page in 1:num_pages) {
    # Calculate the start and end indices for the current page
    start_index <- (page - 1) * movies_per_page + 1
    end_index <- page * movies_per_page
    
    # Extract movie titles for the current page
    current_page_titles <- movie_titles[start_index:end_index]
    
    # Scrape movie specific data
    movie_df <- scrape_movie_data(current_page_titles)
    final_df <- bind_rows(final_df, movie_df)
    
    # Click the year drop down
    drop_down <- remDr$findElement(using = 'css selector', '.mojo-refinement')$clickElement()
    remDr$findElement(using = 'css selector', paste0('li.a-dropdown-item:nth-child(', page + 1, ')'))$clickElement()
    
    # Pause
    Sys.sleep(1)
  }
  
  return(final_df)
}
```

```{r MAIN, eval=FALSE, include=FALSE}
website <- 'https://www.boxofficemojo.com/'
remDr$open()
remDr$navigate(website)
alltime <- remDr$findElement(using = 'link text', 'Worldwide')$clickElement()

#RUN EVERYTHING UNDER HERE TO TEST 

#CHANGE AS NEEDED
num_pages <- 25 
movies_per_page <- 75

# Collect Revenue data
result_data <- scrape_revenue_data(num_pages)
rev_df <- bind_rows(result_data)
# Fix title for movies with (Re-release) to align with website html identifier
rev_df$`Release Group` <- gsub("\\s{2,}(Re-release)", " \\1", rev_df$`Release Group`)
rev_df <- rev_df %>% 
  dplyr::filter(Rank <= movies_per_page)

rev_df

movie_titles <- rev_df$`Release Group`

# Return to first page
drop_down <- remDr$findElement(using = 'css selector', '.mojo-refinement')$clickElement()
remDr$findElement(using = 'css selector',  paste0('li.a-dropdown-item:nth-child(1)'))$clickElement()


movie_df <- scrape_and_aggregate_data(num_pages, movies_per_page, movie_titles)

# Aggregate movie_df and rev_df 
combined_df <- cbind(rev_df, movie_df)

combined_df

# Change File Location to save data
arrow::write_feather(combined_df, 'FIN450_Final.feather')
```

```{r Data Wrangling and Parsing, include=FALSE}

library(lubridate)
library(readxl)
library(dplyr)
library(tidyr)

combined_all <- arrow::read_feather('FIN450_Final.feather')


temp <- combined_all %>% 
  dplyr::select(-Title)

df <- temp[, -15] %>% 
  dplyr::rename(Title = `Release Group`,
                `% Domestic` = `%...5`,
                `% Foreign` = `%...7`,
                Distributor = `Domestic Distributor`) %>% 
  dplyr::mutate(Distributor = sub("See full company information$", "", Distributor),
                Worldwide = parse_number(gsub("[$,]", "", Worldwide)),
                Domestic = parse_number(gsub("[$,]", "", Domestic)),
                Foreign = parse_number(gsub("[$,]", "", Foreign)),
                `Domestic Opening` = parse_number(gsub("[$,]", "", `Domestic Opening`)),
                Budget = parse_number(gsub("[$,]", "", Budget)),
                `% Domestic` = as.numeric(parse_number(`% Domestic`)) / 100,
                `% Foreign` = as.numeric(parse_number(`% Foreign`)) / 100,
                `Earliest Release Date` = mdy(str_extract(`Earliest Release Date`, "[A-Za-z]+ [0-9]+, [0-9]+")),
                Star = str_split(Cast, ", ") %>% map_chr(1),
                Hours = as.numeric(str_extract(`Running Time`, "\\d+(?= hr)")),
                Minutes = as.numeric(str_extract(`Running Time`, "\\d+(?= min)")),
                Hours = ifelse(is.na(Hours), 0, Hours),
                Minutes = ifelse(is.na(Minutes), 0, Minutes),
                `Run Time (Mins)` = Hours * 60 + Minutes,
                Genres = strsplit(Genres, "\r\n[[:space:]]*\\r\\n"),
                Genres = sapply(Genres, function(x) paste(trimws(x), collapse = ", "))) %>%
                dplyr::select(-c(`Running Time`, Hours, Minutes)) %>% 
                dplyr::filter(!grepl("Re-release", Title, ignore.case = TRUE))

df <- df %>%
  dplyr::mutate("Release Month" = month(`Earliest Release Date`, label = TRUE)) %>%
  dplyr::mutate(`Release Month` = as.character(`Release Month`)) %>%
  mutate(`First Genre` = sapply(strsplit(Genres, ", "), `[`, 1)) %>%
  mutate(count_genres = str_count(Genres, ", ") + 1)
df


```

```{r import economic data, include=FALSE}

library(tidyr)
library(tidyquant)
library(dplyr)

# Set get ="economic.data" in tq_get()
import_economic_data <- tidyquant::tq_get(c("DPCCRV1Q225SBEA", "UNRATE", "DGS10"),
                                         get  = "economic.data",
                                         from = "1999-01-01",
                                         to   = Sys.Date()) %>% 
  dplyr::mutate(symbol = dplyr::case_when(symbol == "DPCCRV1Q225SBEA" ~ "Consumer Spending % (USA)",
                                          symbol == "UNRATE" ~ "Unemployment Rate % (USA)",
                                          symbol == "DGS10" ~ "U.S Treasury Yield "))

economic_data <- import_economic_data %>%
  tidyr::pivot_wider(names_from = symbol, values_from = price) %>%
  tidyr::complete(date = seq.Date(from = min(date), to = max(date), by = "1 month")) %>%
  dplyr::arrange(date)  %>%
  dplyr::select(date, `Consumer Spending % (USA)`) %>%
  tidyr::drop_na()

economic_data # df that includes Consumer Spending, Unemployment Rate, and Fed Funds Rate in the United States with aligned dates


theatre_stocks <- tidyquant::tq_get(
  c("IMAX", "CGX", "SPY"),
  get  = "stock.prices",
) %>%
  dplyr::transmute(date, series = symbol, value = adjusted) %>%
  dplyr::group_by(series) %>%
  dplyr::mutate(
    ret = log(value / dplyr::lag(value))
  ) %>%
  dplyr::select(-value) %>%
  tidyr::pivot_wider(names_from = series, values_from = ret) %>%
  tidyr::drop_na()


theatre_stocks #includes returns daily for IMAX and Cineplex stocks


```

REPORT LAYOUT:
- Introduction
- General Analysis and insights (try to find unique insights)
- Analysis of factors affecting revenue 
- ML and prediction of select movies

# **Executive Summary**
1. 
2.
3.
4.

## **Project Framework: Definition and Methodology**
In this report, we will explore the various factors that impact and influence the monetary success of a movie at the box office. Our investigation extends beyond mere fiscal considerations, encompassing a nuanced analysis of important factors such as the expertise of the cast and crew. By scrutinizing these diverse components, this report aims to provide a comprehensive understanding of the factors that defines a movie's monetary success at the box office.

The data was obtained through the use of our own web scraping algorithm and covers the top 75 grossing movies over the past 25 years.
 
 
## **Temporal Analysis**
Over time, the average revenue demonstrates a distinct upward trend, with a notable observation regarding the rate of growth in Foreign revenue compared to Domestic revenue. The surge in global revenue is primarily driven by the rapid expansion of foreign revenue, highlighting the escalating growth and acceptance of Western films in international markets.

The onset of the Covid-19 Pandemic significantly impacted the film industry, evident in the graph. Productions were halted, and theaters closed, leading to a substantial loss of earning potential. The lockdown measures globally disrupted filming schedules, postponed releases, and the closure of theaters eliminated a crucial avenue for revenue. This had a ripple effect across the industry, affecting filmmakers, actors, crew members, distributors, and exhibitors. The industry's vulnerability to external shocks became apparent, prompting the need for innovative adaptations to navigate the challenges such as online releases.

```{r Movie Revenue Trends over Time, echo=FALSE, message=FALSE, warning=FALSE}

revenue <- df %>% 
  dplyr::select(Title, Worldwide, Domestic, Foreign,`Domestic Opening`, `Earliest Release Date`, Year) %>% 
  dplyr::filter(`Earliest Release Date` >= "1999-01-01") %>% 
  stats::na.omit() %>% 
  dplyr::group_by(Year) %>% 
  dplyr::summarise(Avg_Worldwide = mean(Worldwide),
                   Avg_Domestic = mean(Domestic),
                   Avg_Foreign = mean(Foreign))


revenue_plot <- revenue %>% 
  ggplot(aes(x = Year)) +
  geom_line(aes(y = Avg_Worldwide, color = "Avg Worldwide"), size = 1) +
  geom_line(aes(y = Avg_Domestic, color = "Avg Domestic"), size = 1) +
  geom_line(aes(y = Avg_Foreign, color = "Avg Foreign"), size = 1) +
  
  # Add linear regression lines up to a specific date
  geom_smooth(data = . %>% filter(Year <= 2019),
              aes(y = Avg_Domestic), method = "lm", se = FALSE, linetype = "dashed", color = "black") +
  geom_smooth(data = . %>% filter(Year <= 2019),
              aes(y = Avg_Foreign), method = "lm", se = FALSE, linetype = "dashed", color = "black") +
  
  labs(title = "Avg Revenue Over Time",
       x = "Release Date",
       y = "Revenue (in millions)",
       color = "Revenue Type") +
  theme_minimal()


revenue_plot

```

The impact of the month of film release is a fascinating observation. Notably, films hitting the screens in May and June consistently outperform those released in other months. Utilizing an analysis of variance (ANOVA) shows a significant disparity in average revenue across different release months. Several factors contribute to this phenomenon:

1. Summer Blockbuster Season: May and June fall within the traditional summer movie season in numerous regions. Studios strategically unveil high-budget blockbuster films during this period, targeting a broad audience. The warmer weather and school vacations further boost movie attendance.

2. Strategic Release Patterns: The film industry acknowledges this pattern, leading to a clustering effect. Recognizing the advantageous months, more popular and anticipated films tend to be strategically released during May and June. This intentional scheduling capitalizes on the observed heightened audience engagement during these months.

3. Genre Preferences: Certain movie genres, such as action, adventure, and fantasy, are often associated with May and June releases as seen in the graph. These genres tend to draw larger audiences and generate higher revenue, contributing to the observed pattern. (Median Revenue used to account for outliers)
```{r Release Month Analysis, echo=FALSE, message=FALSE, warning=FALSE}

release_month <- df %>% 
  dplyr::select(Title, Worldwide, `Earliest Release Date`, Genres) %>% 
  dplyr::mutate(Month = month(`Earliest Release Date`, label = TRUE)) %>% 
  dplyr::filter(`Earliest Release Date` >= "1999-01-01")

release_month_plot <- release_month %>% 
  dplyr::group_by(Month) %>% 
  dplyr::summarise(AvgRevenue = mean(Worldwide)) %>% 
  ggplot(aes(x = Month, y = AvgRevenue, fill = Month)) +
    geom_bar(stat = "identity") +
    labs(title = "Average Revenue by Release Month", x = "Release Month", y = "Average Revenue") +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 

release_genre <- release_month %>% 
  tidyr::separate_rows(Genres, sep = ", ") %>% 
  dplyr::group_by(Month, Genres) %>% 
  dplyr::summarise(MedianRev = median(Worldwide),
                   Count = n()) %>% 
  dplyr::arrange(desc(MedianRev)) %>% 
  dplyr::filter(Count >= 5) %>% 
  head(10) %>% 
  ggplot(aes(x = factor(Genres, levels = unique(Genres)), y = MedianRev, fill = Month)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Median Revenues by Month and Genre",
       subtitle = "Top 10 (Genres with at least 5 movies)",
       x = "Genres",
       y = "Median Revenue",
       fill = "Month") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_brewer(palette = "Set1")



release_month_plot | release_genre

release_month_anova <- aov(Worldwide ~ Month, data = release_month)
anova_table <- kable(tidy(release_month_anova)) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

anova_table

```

Another notable observation is the seasonality exhibited in the average revenue over a year. The seasonal strength, quantified by a value of 0.5817723, signifies a substantial recurring pattern within our data set.

This strong seasonality implies that there are recurring trends or patterns in revenue that manifest on an annual basis. It suggests that certain times of the year consistently contribute to increased or decreased revenue. Understanding and leveraging this seasonality can be pivotal for strategic decision-making in the realm of film releases.

In practical terms, this finding prompts a closer examination of the temporal distribution of revenue throughout the year. A more detailed exploration of which months or seasons contribute significantly to high or low average revenues can unveil insights that may guide release strategies, marketing efforts, or resource allocation.

```{r Release Month Seasonality, echo=FALSE, message=FALSE, warning=FALSE}

month_seasonality <- release_month %>% 
  dplyr::select(-Genres, -Title) %>% 
  dplyr::arrange(`Earliest Release Date`) %>%
  dplyr::group_by(`Earliest Release Date`) %>% 
  dplyr::summarise(Revenue = mean(Worldwide))

ts <- as_tsibble(month_seasonality, index = `Earliest Release Date`) %>% 
  tsibble::group_by_key() %>%
  tsibble::index_by(freq = ~ yearmonth(.)) %>%
  dplyr::summarise(AvgRevenue = mean(Revenue), .groups = c("keep")) %>% 
  tsibble::fill_gaps()

ts %>% feasts::gg_subseries(AvgRevenue)

ts %>%
  fabletools::features(AvgRevenue, feasts::feat_stl) %>%
  kable("html") %>%
  kable_styling()
```

## **Film Characteristics and Insights**
The genre of a film is a crucial aspect that defines its style, tone, and overall artistic expression. It serves as a blueprint, giving audiences a general idea of what to expect and helping filmmakers convey their vision effectively. The genre serves as a crucial component in the marketing and promotion of a film. It helps studios target specific demographics and tailor promotional campaigns to reach the intended audience.

As illustrated in the chart, Sci-Fi and Adventure emerge as the most lucrative genres within the film industry. This can be primarily attributed to the presence of many blockbuster titles within these specific genres. Despite the presence of outliers, which could represent exceptional cases or singular phenomena, the overarching trend reflected in the chart suggests a consistent and widespread favoritism towards Sci-Fi and Adventure genres. This pattern implies that audiences are consistently drawn to these genres, reinforcing their status as the forefront contributors to the film industry's financial success.

```{r Genre Analysis, echo=FALSE, message=FALSE, warning=FALSE}

genre <- df %>% 
  dplyr::select(Title, Worldwide, Genres) %>% 
  tidyr::separate_rows(Genres, sep = ", ")

genre_plot <- genre %>% 
  ggplot(aes(x = Genres, y = Worldwide, fill = Genres)) +
  geom_boxplot() +
  coord_flip() +  # To make the plot horizontal for better readability
  labs(title = "Revenue Across Genres",
       x = "Genres",
       y = "Revenue") +
  theme(legend.position = "none")

genre_distribution <- genre %>% 
  dplyr::group_by(Genres) %>% 
  dplyr::summarise(Movie_Count = n()) %>% 
  arrange(desc(Movie_Count)) %>% 
  ggplot(aes(x = Genres, y = Movie_Count, fill = Genres)) +
  geom_bar(stat = "identity") +
  labs(title = "Distribution of Movies Across Different Genres",
         x = "Genres",
         y = "Movie Count") +
  coord_flip() +
  theme(legend.position = "none")

genre_plot

```

Upon analyzing the revenue distributions across genres, a notable observation emerged: the box plots for the Fantasy and Family genres exhibited remarkable similarity. This observation prompted a deeper exploration into the correlations among various genre combinations.

A noteworthy finding was the high positive correlation between the Animation and Family genres. This correlation aligns seamlessly with the prevalent trend of animated family-oriented films. Conversely, an intriguing insight surfaced when examining the negative correlation between Thriller and Comedy genres. This distinctive relationship suggests an unconventional pairing that has not been extensively explored in the cinematic landscape.

This negative correlation sparks a thought-provoking notion â€” the potential for an innovative and revolutionary genre combination. The rarity of Thriller-Comedy hybrids in the current cinematic landscape presents an opportunity for filmmakers to experiment. This unexplored territory not only provides creative potential but also introduces the possibility of captivating a diverse audience with a novel cinematic experience.

```{r echo=FALSE, message=FALSE, warning=FALSE}
genre_occurrence <- genre %>% 
  count(Title, Genres) %>%
  filter(n > 0) %>%
  spread(Genres, n, fill = 0) %>%
  mutate(across(everything(), as.numeric))

correlation_matrix <- cor(genre_occurrence[, -c(1, 2)])
corrplot(correlation_matrix, method = "color", addrect = 2)
```

Movies often navigate across various genres to broaden their appeal and cater to a diverse demographic. The trend indicates that a film's performance tends to improve as it incorporates multiple genres, with the optimal balance appearing to be around six genres.

```{r echo=FALSE, message=FALSE, warning=FALSE}
genres_per_movie <- df %>% 
  dplyr::select(Title, Worldwide, Genres) %>% 
  dplyr::mutate(Genre_Count = str_count(Genres, ",") + 1) %>% 
  dplyr::group_by(Genre_Count) %>% 
  dplyr::summarise(Avg_rev = mean(Worldwide),
                   Movie_Count = n()) %>% 
  ggplot(aes(x = factor(Genre_Count), y = Avg_rev, fill = factor(Genre_Count))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Movie_Count), vjust = -0.5) +  # Display movie count on top of bars
  labs(title = "Avg Revenue by Number of Genres and Number of Movies",
       x = "Number of Genres",
       y = "Avg Revenue") +
  theme_minimal() +
  theme(legend.position = "none")

genres_per_movie
```

```{r Cast Analysis}
cast <- df %>% 
  dplyr::select(Title, Worldwide, Cast) %>% 
  tidyr::separate_rows(Cast, sep = ", ") %>% 
  dplyr::group_by(Cast) %>% 
  dplyr::summarise(AvgRev = mean(Worldwide),
                   Count = n()) %>% 
  dplyr::mutate(Movies_Acted = case_when(
    Count >= 5 & Count <= 10 ~ '5-10',
    Count > 10 & Count <= 15 ~ '10-15',
    Count > 15 & Count <= 20 ~ '15-20',
    Count > 20 ~ '20+',
    TRUE ~ 'Less than 5'
  )) %>% 
  dplyr::group_by(Movies_Acted) %>% 
  dplyr::summarise(AvgRev = mean(AvgRev),
                   Count = n()) %>% 
  dplyr::arrange(desc(AvgRev))
cast
# Changing preference for newer faces or different types of story telling. Still like regulars 
range_order <- c("Less than 5", "5-10", "10-15", "15-20", "20+")
cast$Movies_Acted <- factor(cast$Movies_Acted, levels = range_order)
ggplot(cast, aes(x = Movies_Acted, y = AvgRev, fill = factor(Count))) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  scale_fill_viridis_d() +
  labs(title = "Average Revenue by Number of Movies Acted",
       x = "Movies_Acted",
       y = "Average Revenue",
       fill = "Count") +
  theme_minimal()
star <- df %>% 
  dplyr::select(Worldwide, Star) %>% 
  dplyr::group_by(Star) %>% 
  dplyr::summarise(AvgRev = mean(Worldwide),
                   Count = n()) %>% 
  dplyr::filter(Count >= 5) %>% 
  dplyr::arrange(desc(AvgRev))
star
star_plot <- star %>%  
  ggplot(aes(x = Count, y = AvgRev, size = Count, color = Count,
             text = paste("Star:", Star, "<br>Number of Movies:", Count, "<br>Average Revenue:", scales::dollar(AvgRev)))) +
  geom_point() +
  labs(title = "Movie Stars and Avg Revenue",
       x = "Number of Movies",
       y = "Average Revenue",
       size = "Number of Movies")
plotly::ggplotly(star_plot, tooltip = "text")
```

```{r Writer Analysis}
#RUN REGRESSION ANALYSIS

writer <- df %>% 
  dplyr::select(Title, Worldwide, Writer) %>% 
  stats::na.omit() %>% 
  dplyr::mutate(Writer_Count = str_count(Writer, ",") + 1) %>%
  dplyr::mutate(Grouped_Writer_Count = ifelse(Writer_Count >= 10, 10, Writer_Count)) %>%
  dplyr::group_by(Grouped_Writer_Count) %>% 
  dplyr::summarise(AvgRevenue = mean(Worldwide),
                   Count = n())

writer

```


```{r Director Analysis}
# FIND AND GRAPH THE TOP DIRECTORS
# DIRECTOR GENRE GRAPH

director <- df %>% 
  dplyr::select(Title, Worldwide, Director) %>% 
  dplyr::mutate(Director_Count = str_count(Director, ",") + 1) %>% 
  dplyr::group_by(Director_Count) %>% 
  dplyr::summarise(AvgRevenue = median(Worldwide),
                   Count = n()) %>% 
  dplyr::filter(Count > 2)

director

```

MACHINE LEARNING

```{r regression tree analysis}

library(dplyr)
library(parsnip)
library(ggplot2)
# Split data
set.seed(123)  # Set a seed for reproducibility
#df_shuffled <- df[sample(nrow(df)), ] # Shuffle data to elimate some bias hopefully/
df_split <- df %>% rsample::initial_split(prop = 0.80)
df_train <- rsample::training(df_split)
df_test  <- rsample::testing(df_split)

# Worldwide as dependent variable
recipe_pipeline <- recipes::recipe(Worldwide ~ Budget + Distributor + `Release Month` + MPAA + `Run Time (Mins)` + `First Genre`+`count_genres`, data = df_train) %>%
  # step_rm(date) %>%
  recipes::prep()

train_baked <- recipes::bake(recipe_pipeline, df_train)

recipe_pipeline <- recipes::recipe(Worldwide ~ Budget + Distributor + `Release Month` + MPAA + `Run Time (Mins)` + `First Genre`+`count_genres`, data = df_test) %>%
  # step_rm(date) %>%
  recipes::prep()

test_baked <- recipes::bake(recipe_pipeline, df_test)  # Corrected to use test_baked


common_levels_distributor <- intersect(levels(train_baked$Distributor), levels(test_baked$Distributor))
train_baked$Distributor <- factor(train_baked$Distributor, levels = common_levels_distributor)
test_baked$Distributor <- factor(test_baked$Distributor, levels = common_levels_distributor)



# Modeling
model <- parsnip::decision_tree(mode = "regression") %>%
  parsnip::set_engine("rpart") %>%
  parsnip::fit(Worldwide ~ Budget + Distributor + `Release Month` + MPAA + `Run Time (Mins)` + `First Genre`+`count_genres`, data = train_baked)
model

test_predictions <- predict(model, new_data = test_baked)
test_predictions


# Plot tree
library(rpart.plot)
rpart.plot(
  model$fit,
  roundint = F,
  cex = 1,
  fallen.leaves = F,
  extra = "auto",
  main = "Regression Tree"
)

# Results
res <- model %>% predict(new_data = test_baked) %>%
  bind_cols(test_baked %>% dplyr::select(Worldwide))
res %>% yardstick::metrics(truth = Worldwide, estimate = .pred)

res %>% ggplot(aes(x = .pred, y = Worldwide)) + geom_point() +
  labs(title = "Prediction vs Actual",
       subtitle = "Decision Tree - Regression")

# Assuming 'model' is your decision tree model and 'df_test' is your testing data
library(parsnip)
library(yardstick)
library(vip)

# Assess variable importance
importance <- model %>% vip()

# Assess variable relationships
plot(importance)


```

```{r eval=FALSE, include=FALSE}

# Example: Create a data frame for prediction
unreleased_movie_data <- data.frame(
  Budget = 160000000,  # Replace with the actual budget value
  Distributor = "Lions Gate Films",  # Replace with the actual distributor value
  `Release Month` = "Nov",  # Replace with the actual release month value
  MPAA = "PG-13",  # Replace with the actual MPAA rating value
  `Run Time (Mins)` = 137,
  `First Genre` = "Action",
  `count_genres` = 4,
)

library(dplyr)

# Example: Rename columns in the tibble
unreleased_movie_data <- unreleased_movie_data %>%
  dplyr::rename(
    Budget = Budget,
    Distributor = Distributor,
    `Release Month` = `Release.Month`,
    MPAA = MPAA,
    `Run Time (Mins)` = `Run.Time..Mins.`,
    `First Genre` = `First.Genre`
  )


unreleased_movie_data

unreleased_movie_baked <- recipes::bake(recipe_pipeline, unreleased_movie_data)
prediction <- predict(model, unreleased_movie_baked)

print(prediction)


```

```{r eval=FALSE, include=FALSE}
# Sampling
df_split2 <- df %>% rsample::initial_time_split(prop = 0.9999)
df_train2 <- rsample::training(df_split2)

# Training Data
recipe_pipeline2 <- recipes::recipe(Worldwide ~ Budget + 
                                      Distributor + 
                                      `Earliest Release Date` + 
                                      MPAA + 
                                      `Run Time (Mins)` + 
                                      Star, 
                                    data = df_train2) %>%
  recipes::step_mutate(Budget_Category = cut(Budget, 
                                     breaks = c(-Inf, 75000000, 150000000, Inf), 
                                     labels = c("Small", "Medium", "Large"))) %>% 
  step_mutate(Release_Month = month(`Earliest Release Date`, label = TRUE)) %>%
  step_mutate(Run_Time_Category = ifelse(`Run Time (Mins)` < 120, "Regular", "Long")) %>%
  step_dummy(Star, one_hot = TRUE) %>%
  recipes::prep()

train_baked2 <- recipes::bake(recipe_pipeline2, df_train2)

# MODEL
lm_fit <- parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine("lm") %>%
  parsnip::fit(Worldwide ~ ., data = train_baked2)

# PREDICTION
new_data <- tibble::tibble(
  Budget = 97000000,  # Replace with your budget value
  Distributor = "Twentieth Century Fox",  # Replace with your distributor
  `Earliest Release Date` = as.Date("2017-03-17"),  # Replace with your release date
  MPAA = "R",  # Replace with your MPAA rating
  `Run Time (Mins)` = 137,  # Replace with your run time
  Star = "Hugh Jackman",
  Director_Count = 1,
  Writer_Count = 4
)


# Bake the new data using the same recipe
new_data_baked <- recipes::bake(recipe_pipeline2, new_data)

# Make predictions using the trained model
predictions <- predict(lm_fit, new_data_baked)

# View the predicted worldwide revenue
predictions

# Training Data
df_train3 <- df_train2 %>% 
  dplyr::mutate(Director_Count = str_count(Director, ",") + 1,
                Writer_Count = str_count(Writer, ",") + 1)

recipe_pipeline3 <- recipes::recipe(Worldwide ~ Budget + 
                                      Distributor + 
                                      `Earliest Release Date` + 
                                      MPAA + 
                                      `Run Time (Mins)` + 
                                      Director_Count +
                                      Writer_Count,
                                    data = df_train3) %>%
  recipes::step_mutate(Budget_Category = cut(Budget, 
                                     breaks = c(-Inf, 75000000, 150000000, Inf), 
                                     labels = c("Small", "Medium", "Large"))) %>% 
  step_mutate(Release_Month = month(`Earliest Release Date`, label = TRUE)) %>%
  step_mutate(Run_Time_Category = ifelse(`Run Time (Mins)` < 120, "Regular", "Long")) %>%
  recipes::prep()

train_baked3 <- recipes::bake(recipe_pipeline3, df_train3)

options(mc.cores = parallel::detectCores())
model_bayes <-
  parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine(
    "stan",
    prior_intercept = rstanarm::normal(),
    prior = rstanarm::student_t(df = 1),
    iter = 4000,
    seed = 123
  ) %>%
  parsnip::fit(Worldwide ~ . ,  data = train_baked3)

new_data_baked2 <- recipes::bake(recipe_pipeline3, new_data)
predictions2 <- predict(model_bayes, new_data_baked2)

test <- df %>% 
  dplyr::group_by(Distributor) %>% 
  dplyr::summarise(count = n()) %>% 
  dplyr::arrange(desc(count))
test

```

